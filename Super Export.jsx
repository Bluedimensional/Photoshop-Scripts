(function(){    var doc =  app.activeDocument;        app.preferences.rulerUnits = Units.PIXELS;    app.preferences.typeUnits = TypeUnits.PIXELS;        /********************************************************************************/    /*********************************  REVERT  *************************************/    var originalHistoryState = doc.activeHistoryState;        var layersSettings = [];    eachLayer(function(layer){        layersSettings[layersSettings.length] = {            layer: layer,            visible: layer.visible        };    });        function revert_all(){        doc.activeHistoryState = originalHistoryState;        revert_layer_visibilities();    }        function revert_layer_visibilities(){        for(var i=0; i<layersSettings.length; i++){            var layerSettings = layersSettings[i];		    if(layerSettings.layer.visible != layerSettings.visible)                layerSettings.layer.visible = layerSettings.visible;        }    }        /********************************************************************************/    /********************************  EXTENSIONS  **********************************/    String.prototype.trim = function(){        return this.replace(/^ */, "").replace(/ *$/, "");    }         function keys(obj){        var keys = [];        for(i in obj) if (obj.hasOwnProperty(i))        {            keys.push(i);        }        return keys;    };        function clone(obj){        if(obj == null || typeof(obj) != 'object')            return obj;        var temp = {}; // changed, obj.constructor()        for(var key in obj)            temp[key] = clone(obj[key]);        return temp;    }    Array.prototype.indexOf = function(el) {        for (var i = 0; i < this.length; i += 1) {            if (this[i] == el) return i;        }        return -1;    };        Array.prototype.lastIndexOf = function(el) {        for (var i = this.length-1; i >= 0; i -= 1) {            if (this[i] == el) return i;        }        return -1;    };        Array.prototype.distinct = function() {        var derivedArray = [];        for (var i = 0; i < this.length; i += 1) {            if (derivedArray.indexOf(this[i]) == -1) {                derivedArray.push(this[i])            }        }        return derivedArray;    };        Array.prototype.each = function(callback) {        var derivedArray = [];        for (var i = 0; i < this.length; i += 1) {            derivedArray.push(callback(this[i], i));        }        return derivedArray;    };            /********************************************************************************/    /*****************************  LAYER ENUMERATION  ******************************/        function buildCacheForLayer(layer){                var cache = {            layerRef: layer,            layers: []        };        if(layer.layers)          for(var i=0; i<layer.layers.length; i++)            cache.layers[i] = buildCacheForLayer(layer.layers[i]);                return cache;    }        function findCacheForLayer(layer, currentCache){        currentCache = currentCache || rootLayerCache;        if(layer == currentCache.layerRef)            return currentCache;                for(var i=0; i<currentCache.layers.length; i++){            var newCache = findCacheForLayer(layer, currentCache.layers[i]);            if(newCache)                return newCache;        }        return null;    }        var rootLayerCache = null;    function eachLayer(callback, layer){        if(rootLayerCache == null)            rootLayerCache = buildCacheForLayer(doc);                var each = function(callback, layerCache){            for(var i=0; i<layerCache.layers.length; i++){                if(callback(layerCache.layers[i].layerRef) == false)                    return false;                if(each(callback, layerCache.layers[i]) == false)                    return false;            }        };                each(callback, findCacheForLayer(layer || doc));    }        /********************************************************************************/    /*********************************  HELPERS  ************************************/    function cropToLayer(layer){        var bounds = layer.bounds;        if(!bounds) return;        doc.crop(bounds);    }        function hideSiblingsOfSelfAndOfParent(layer){        if(layer.typename == "Document")            return; //document has no siblings        for(var i=0; i<layer.parent.layers.length; i++){            var currentLayer = layer.parent.layers[i];            if(layer == currentLayer)                continue;            			if(currentLayer.visible != false)                 currentLayer.visible = false;        }        hideSiblingsOfSelfAndOfParent(layer.parent);    }    function getSaveOptions(layerInfo){        if(layerInfo.extension == "jpg"){            var options = new JPEGSaveOptions();            options.matte = MatteType.BACKGROUND;            //Quality            if(layerInfo.q){                if(isNaN(parseFloat(layerInfo.q)) == false){                    layerInfo.q = Math.max(Math.min(parseFloat(layerInfo.q), 100), 0);                    if(layerInfo.q<=1){                        layerInfo.q = Math.round(layerInfo.q*12);                    }else if(layerInfo.q > 12){                        layerInfo.q = Math.round((layerInfo.q/100.0)*12);                    }                }            }            options.quality = layerInfo.q || 10;             return options;        }else if(layerInfo.extension == "png"){            var options = new PNGSaveOptions();            options.matte = MatteType.NONE;            return options;        }    }    function convertLayerNameToInfo(name){        var info = { name:name, tags:{}, hasTags:false };                // Get tags        if(name.indexOf("-") != -1){            var tags = name.substring(name.lastIndexOf("-")+1).trim().split(",");		    for(var i=0; i<tags.length; i++){		        var t = tags[i].split(":");                if(t.length == 1){                    t[1] = t[0].trim();                    t[0] = "0";                }else{                    t[0] = t[0].trim();                    t[1] = t[1].trim();                }			    info.tags[t[0]] = t[1];		    }            name = name.substring(0, name.lastIndexOf("-")).trim();            info.hasTags = true;        }                // Split by Comma        var sections = name.split(",");        for(var i=0; i<sections.length; i++){            var section = sections[i].trim();            //No Colon, So Maybe A Filename            if(section.indexOf(":") == -1){                var extension = section.match(/(jpg|png)$/i);                if(extension){                    info.filename = section;                    info.extension = extension[0].toLowerCase();                }            //Colon, So Split Into Key/Value            }else{                var fieldParts = section.split(":");                info[fieldParts[0].trim().toLowerCase()] = fieldParts[1].trim();            }        }        return info;    }        var getCurrentDocumentIndex = function(){        for(var i=0; i<app.documents.length; i++){            if(app.activeDocument == app.documents[i])                return i;        }        alert("Current document index not found.");    }        var getPath = function(){        if(app.documents.length == 1 || !new RegExp(/TemporaryItems/).test(app.activeDocument.path))            return app.activeDocument.path;        var newIndex = (getCurrentDocumentIndex()-1) % app.documents.length;        return app.documents[newIndex].path;    };                /********************************************************************************/    /**********************************  MAIN  **************************************/    /**     *  - Take an initial snapshot so we don't change any of their settings     *  - If a folder is named with an extension (.jpg, etc) then      *    - Hide siblings of self & parent folders     *    - If current folder has a 'Crop' layer, then use it to crop     *  - Restore to initial snapshot     */    //try{        eachLayer(function(layer){            if(layer.typename == "LayerSet"){                //Get the extension                var info = convertLayerNameToInfo(layer.name);                if(!info.filename) return;                //Crop if need be                for(var i=0; i<layer.layers.length; i++){                    var l = layer.layers[i];                    if(l.name.match(/^ *crop *$/i)){                        cropToLayer(l);                    }                }                //Hide bad stuff                hideSiblingsOfSelfAndOfParent(layer);                //Prepare saving function                var save = function(filename){                    //Save                    var filepath = getPath()+"/"+filename;                    doc.saveAs(new File(filepath), getSaveOptions(info), true, Extension.LOWERCASE);                    //Retina?                    if(info.filename.match(/@2x[.][a-z]+$/)){                        doc.resizeImage(doc.width/2, doc.height/2, doc.resolution, ResampleMethod.BICUBICSHARPER);                                            var filepath = getPath()+"/"+filename.replace("@2x", "");                        doc.saveAs(new File(filepath), getSaveOptions(info), true, Extension.LOWERCASE);                    }                }                                //Hide hashed                eachLayer(function(l){                    if(l.name.indexOf("#") != -1)					   if(l.visible != false)                            l.visible = false;                });                                //save once for each tagged layer inside this layerset                if(new RegExp(/\{[^}]+\}/).test(info.filename)){                    //gather all possible tags & tag values                    var allTags = {};                    eachLayer(function(l){                        var info = convertLayerNameToInfo(l.name);                        var currentTags = keys(info.tags);                        for(var i=0; i<currentTags.length; i++){                            var t = currentTags[i];                            if(allTags[t]){                                allTags[t] = allTags[t].concat([ info.tags[t] ]).distinct();                               }else{                                allTags[t] = [ info.tags[t] ];                            }                        }                    }, layer);                    var allKeys = keys(allTags);                                        //create a strategy for covering all tag combinations                    var allCombinations = [];                    var addTagSetToCombinations = function(tag, tagValues){                        //no previous combos, so just add ours                        if(allCombinations.length == 0){                            for(var i=0; i<tagValues.length; i++){                                var combo = {};                                combo[tag] = tagValues[i];                                allCombinations.push(combo);                            }                                                //explode our tag into previous combos                        }else{                            var newCombos = [];                            for(var i=0; i<allCombinations.length; i++){                                for(var j=0; j<tagValues.length; j++){                                    var newCombo = clone(allCombinations[i]);                                    newCombo[tag] = tagValues[j];                                    newCombos.push(newCombo);                                }                            }                            allCombinations = newCombos;                        }                    };								   //actually create the combinations				   allKeys.each(function(key){				       addTagSetToCombinations(key, allTags[key]);				   });                                        //save each combo                   for(var i=0; i<allCombinations.length; i++){                        var combo = allCombinations[i];                        eachLayer(function(l){                            var info = convertLayerNameToInfo(l.name);                            if(!info.hasTags) return;                                                        var visible = true;                            keys(info.tags).each(function(key){						       visible &= info.tags[key] == combo[key];						    });						    l.visible = visible;                        }, layer);                                                //create filename                        var filename = info.filename;                        allKeys.each(function(key){                            filename = filename.replace("{"+key+"}", combo[key]);                         });				                          //save                        save(filename);                    }                                    //save normally (no swapable layers)                }else{                    save(info.filename);                }                                revert_all();            }        });    //}catch(error){     //   if(!confirm("Error in main: "+error))     //       return false;     //}    revert_all();})();